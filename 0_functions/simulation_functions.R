# User-defined functions --------------------------------------------------

# This function simulates gatherings for a population of size N drawn from BBC
# Pandemic data and then assumes prevalence of infection and recovered are given
# by pi and pr respectively. It assigns people to gatherings and then simulates
# the number of secondary cases generated by each gathering. The function also
# allows us to specify the distribution for nu.
simulate_gatherings <- function(N,
                                pi,
                                pr,
                                sims = 1,
                                option = "0",
                                c = 10,
                                dist,
                                prior = function(x) rbeta(x, 0.08, 0.92)) {
  
  # draw gatherings from empirical distribution
  M <- draw_gatherings(N, c, dist, option)
  
  # assign S, I, R to gatherings
  gath_SIR <- draw_SIR_attendees(N, M, pi, pr)

  # draw infectiousness probability (q) for each infected and simulate
  # sequence of infections to get effective r for each infected]
  X <-
    mapply(
      infect,
      S = gath_SIR[, "S"],
      I = gath_SIR[, "I"],
      R = gath_SIR[, "R"],
      MoreArgs = list(
        q_dist = prior
      ),
      SIMPLIFY = FALSE
    )
  
  # subset among gatherings in which an infected attended
  X_eff <- unlist(X[which(gath_SIR[, "I"] > 0)])
  
  if (length(X_eff) == 0) {
    X_eff <- 0
  }
  
  # calculate total number infected at gathering
  delta <- sapply(X, sum)
  gath_SIR <- cbind(gath_SIR, delta)
  
  # return results
  res <- list(
    "SIR" = gath_SIR,
    "X" = unlist(X),
    "X_eff" = X_eff, 
    "delta" = delta
  )
  
  return(res)
}

# draw_gatherings() function generates M, a vector of gatherings drawn from the
# BBC pandemic distribution so that in total N people attend,
# under 4 options for restriction in gathering size up to c : 
# 0 for no restriction, 
# 1 for replacement by c, 
# 2 for replacement by 0 and 
# 3 for replacement by another draw smaller to c
draw_gatherings <- function(N = 10000, #10000 as default, can change
                            c = 10, # cut-off as default, can change
                            dist = bbc$M, #use the bbc data distribution
                            option = "0") { # define options for restriction (1, 2, or 3)
  # initialize loop variables
  M <- vector()
  i <- 1
  # loop until sum of gatherings is equal to pop size
  while(sum(M) != N) {
    # draw gathering of size m from BBC pandemic distribution
    M[i] <- sample(dist, 1) 
    if (M[i] > c) {
      M[i] <- switch(
        option,
        # option 0 : no restriction to gathering size 
        "0" = M[i],
        # option 1: set to c (most conservative)
        "1" = c,
        # option 2: set to 1 (least conservative)
        "2" = 1,
        # option 3: redraw until less than c (realistic?) 
        "3" = sample(dist[dist <=c], 1)
      )
    }
    # if sum(m) is less than pop size, then advance to next gathering
    # otherwise redraw existing gathering
    if (sum(M) <= N) { 
      i <- i + 1
    } 
  } 
  return(M)
} 

# assign S, I, R to gatherings
draw_SIR_attendees <- function(N, M, pi, pr) {
  
  # define vector of population states based on pi and pr
  states <- c(
    rep("S", N - floor(pi * N) - floor(pr * N)),
    rep("I", floor(pi * N)),
    rep("R", floor(pr * N))
  )

  # for each gathering sample M from vector of population states to attend
  # gathering and tabulate numbers of S, I, and R
  gath_SIR <- lapply(M, function (x) table(sample(states, x)))
  
  gath_SIR <- bind_rows(gath_SIR)  
  
  cols <- c("S", "I", "R")
  
  # if no S, I, or R are sampled in any a gatherings add a zero column
  if (ncol(gath_SIR) != 3) {
    cols_to_add <- cols[!cols %in% names(gath_SIR)]
    gath_SIR[, cols_to_add] <- 0
  }
  
  # reorder order to be always the same
  gath_SIR <- gath_SIR[, cols]
  
  # replace NAs by zeros
  gath_SIR <-
    rapply(
      gath_SIR,
      f = function(x)
        ifelse(is.na(x), 0, x),
      how = "replace"
    )
  
  return(as.matrix(gath_SIR))
  
}

# simulate infection
infect <- function(S,
                   I,
                   R,
                   q_dist = function(x)
                     rbeta(x, 0.5, 0.95)) {
  
  if (I != 0) {
    # draw individual probability of infectiousness using hierarchical
    # beta-binomial approach
    q_i <- q_dist(I)
    
    # initialize counters
    E <- 0
    X <- vector()
    
    # loop over infecteds and determine number of successful secondary cases
    # using draw from binomial distribution where N = # of remaining
    # susceptible and p = probability of infection given contact (q)
    for (k in 1:I) {
      X[k] <- rbinom(1, S - E, q_i[k])
      E <- E + X[k]
    }
  } else {
    X <- 0
  }
  return(X)
}

# This function caluclates summary stats about secondary cases
summarize_dgp <- function(x) {
  c(
    "mean" = mean(x),
    "median" = median(x),
    "q1" = quantile(x, 0.25, names = F),
    "q3" = quantile(x, 0.75, names = F),
    "sd" = sd(x)
  )
}

# distribution functions for binomial and beta-binomial distributions
binom_cdf <- function(x, size, p) pbinom(x, size, p)
betabinom_cdf <- function(x, size, p, phi) rmutil::pbetabinom(x, size, p, phi)

binom_pmf <- function(x, size, p) dbinom(x, size, p)
betabinom_pmf <- function(x, size, p, phi) rmutil::dbetabinom(x, size, p, phi)

# keeping older code with simple case to be able to easily manually check that
# the function works fine
if (FALSE) {
  # apply the draw_SIR_attendees() function to each of the gatherings from draw_gatherings()
  # get distribution of S, I and R in each gathering 
  N <- 10000
  pi <- 0.05
  pr <- 0.05 
  
  # draw gatherings
  gath <- draw_gatherings(option = "0")
  head(gath)
  
  # define vector of population states based on pi and pr
  states <- c(
    rep("S", N - floor(pi * N) - floor(pr * N)),
    rep("I", floor(pi * N)),
    rep("R", floor(pr * N))
  )
  
  # for each gathering sample M from vector of population states to attend
  # gathering and tabulate numbers of S, I, and R
  # for each gathering sample M from vector of population states to attend
  # gathering and tabulate numbers of S, I, and R
  # gath_states <-
  #   lapply(gath, function (x)
  #     as.data.frame(t(as.matrix(table(
  #       sample(states, x)
  #     )))))
  # 
  # gath_states <- bind_rows(gath_states)
  # 
  ## Shorter way of coding this
  gath_states <- lapply(gath, function (x) table(sample(states, x)))
  gath_states <- bind_rows(gath_states)

  #reorder order to be always the same
  #colnames(gath_states)
  col_order <- c("S", "I", "R")
  gath_states <- gath_states[, col_order]
  head(gath_states)
  
  #replace NAs by zeros 
  gath_states <- rapply( gath_states, f=function(x) ifelse(is.na(x),0,x), how="replace" )
  
  # gath_states[is.na(gath_states)] <- 0
  
  #test
  head(gath_states)
  tail(gath_states)
  
  # test of simulate_gatherings
  N <- 10000
  pi <- 0.05
  pr <- 0.05 
  
  bbc <- read_csv("1_data/contact_dist_BBCPandemic/contact_distributions_o18.csv")
  bbc <- select(bbc, e_other)
  bbc$M <- bbc$e_other + 1
  
  simulate_gatherings(N, pi, pr, dist = bbc$M)
}


